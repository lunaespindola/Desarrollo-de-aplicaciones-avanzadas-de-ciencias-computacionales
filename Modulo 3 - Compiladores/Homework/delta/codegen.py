from arpeggio import PTNodeVisitor


class CodeGenerationVisitor(PTNodeVisitor):

    WAT_TEMPLATE = ''';; Code generated by the Delta compiler
(module
  (func
    (export "_start")
    (result i32)
{}  )
)
'''

    def __init__(self, symbol_table, **kwargs):
        super().__init__(**kwargs)
        self.__symbol_table = symbol_table

    def visit_program(self, node, children):

        def declare_variables():
            return ''.join([f'    (local ${var_name} i32)\n'
                            for var_name in self.__symbol_table])

        return CodeGenerationVisitor.WAT_TEMPLATE.format(
            declare_variables()
            + ''.join(children))

    def visit_statement(self, node, children):
        return children[0]

    def visit_declaration(self, node, children):
        return ''

    def visit_assignment(self, node, children):
        return children[1] + children[0]

    def visit_if(self, node, children):
        result = (children[0]
                  + '    if\n'
                  + children[1])
        if len(children) == 3:
            result += ('    else\n'
                       + children[2])
        result += '    end\n'
        return result

    def visit_while(self, node, children):
        return (
              '    block\n'
            + '    loop\n'
            + children[0]
            + '    i32.eqz\n'
            + '    br_if 1\n'
            + children[1]
            + '    br 0\n'
            + '    end\n'
            + '    end\n')

    def visit_block(self, node, children):
        return ''.join(children)

    def visit_lhs_variable(self, node, children):
        name = node.value
        return f'    local.set ${name}\n'

    def visit_expression(self, node, children):
        if len(children) == 1:
            return children[0]

        result = children[0]  # Evaluate the first expression

        for exp in children[1:]:
            # Check if the previous expression's result was non-zero (true)
            result += (
                '    i32.const 0\n'  # Push 0 to the stack for comparison
                + '    i32.ne\n'      # Check if not equal to 0 (i.e., true)
                + '    if (result i32)\n'  # If true, evaluate the next expression
                + exp
                + '    i32.const 0\n'  # Push 0 to the stack for comparison in the next iteration
                + '    i32.ne\n'      # Ensure the result is 0 or 1
                + '    else\n'        # If the previous result was false, push 0 and continue
                + '    i32.const 0\n'
                + '    end\n'
            )

        return result


    def visit_additive(self, node, children):
        result = [children[0]]
        for i in range(1, len(children), 2):
            result.append(children[i + 1])
            match children[i]:
                case '+':
                    result.append('    i32.add\n')
                case '-':
                    result.append('    i32.sub\n')
        return ''.join(result)

    def visit_multiplicative(self, node, children):
        result = [children[0]]
        for i in range(1, len(children), 2):
            result.append(children[i + 1])
            match children[i]:
                case '*':
                    result.append('    i32.mul\n')
                case '/':
                    result.append('    i32.div_s\n')
                case '%':
                    result.append('    i32.rem_s\n')
        return ''.join(result)
    
    def visit_comparison(self, node, children):
        result = children[0]
        i = 1
        while i < len(children):
            operator = children[i]
            rhs = children[i + 1]
            result += rhs
            if operator == '==':
                result += '    i32.eq\n'
            elif operator == '!=':
                result += '    i32.ne\n'
            elif operator == '>=':
                result += '    i32.ge_s\n'
            elif operator == '>':
                result += '    i32.gt_s\n'
            elif operator == '<=':
                result += '    i32.le_s\n'
            elif operator == '<':
                result += '    i32.lt_s\n'
            i += 2
        return result
    
    def visit_do_while(self, node, children):
        return (
            '    block\n'  # Outer block to enable exit from the loop
            + '    loop\n'  # Loop start
            + children[0]  # Execute the loop body first
            + children[1]  # Condition expression
            + '    i32.eqz\n'  # Check if the expression is zero (false)
            + '    br_if 1\n'  # Break out of loop if condition is false
            + '    br 0\n'  # Continue loop
            + '    end\n'  # End loop
            + '    end\n'  # End block
        )

    def visit_decimal(self, node, children):
        return f'    i32.const { node.value }\n'

    def visit_boolean(self, node, children):
        if children[0] == 'true':
            return '    i32.const 1\n'
        else:
            return '    i32.const 0\n'
    
    def visit_binary(self, node, children):
        node.value = int(node.value[2:], 2)
        return f'    i32.const {node.value}\n'

    def visit_octal(self, node, children):
        node.value = int(node.value[2:], 8)
        return f'    i32.const { node.value }\n'
    
    def visit_hexadecimal(self, node, children):
        node.value = int(node.value[2:], 16)
        return f'    i32.const { node.value }\n'    

    def visit_parenthesis(self, node, children):
        return children[0]

    def visit_unary(self, node, children):
        result = children[-1]
        for op in children[-2::-1]:
            match op:
                case '+':
                    ... # do nothing
                case '-':
                    result = (
                        '    i32.const 0\n'
                        + result
                        + '    i32.sub\n'
                    )
                case '!':
                    result += '    i32.eqz\n'
        return result

    def visit_rhs_variable(self, node, children):
        name = node.value
        return f'    local.get ${name}\n'